<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <title>üîí Client-only Cryptor</title>

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css">
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">

  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 700px;
      margin: 2rem auto;
    }

    button {
      background-color: #4caf50;
      color: white;
      border-radius: 8px;
      padding: 12px 20px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      transition: background-color 0.3s ease, transform 0.3s ease;
    }

    button:hover {
      background-color: #45a049;
      transform: scale(1.05);
    }

    /* –°—Ç–∏–ª—å –¥–ª—è –ø–æ–ª–µ–π –≤–≤–æ–¥–∞ */
    textarea, input {
      border-radius: 8px;
      padding: 12px;
      font-size: 1rem;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    }

    textarea:focus, input:focus {
      outline: none;
      box-shadow: 0 0 10px rgba(66, 133, 244, 0.5);
    }

    .result {
      opacity: 0;
      transition: opacity 0.5s ease-in-out;
    }

    .result.show {
      opacity: 1;
    }
  </style>
</head>

<body class="container">
  <h3 class="center-align" style="margin-top: 40px;">
    üîí Client-Only Cryptor
  </h3>

  <!-- ENCRYPT BLOCK -->
  <div class="card" style="margin-top: 30px;">
    <div class="card-content">
      <span class="card-title">–®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ</span>

      <div class="input-field">
        <textarea id="textEncrypt" class="materialize-textarea"></textarea>
        <label for="textEncrypt">–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç</label>
      </div>

      <div class="input-field">
        <input id="keyEncrypt" type="text">
        <label for="keyEncrypt">–ö–ª—é—á (–æ—Å—Ç–∞–≤—å—Ç–µ –ø—É—Å—Ç—ã–º –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏)</label>
      </div>

      <button class="btn green waves-effect waves-light" id="encryptBtn">
        <i class="material-icons left">lock</i>–®–∏—Ñ—Ä–æ–≤–∞—Ç—å
      </button>

      <button class="btn blue lighten-1 waves-effect waves-light" id="genKeyBtn" style="margin-left:10px;">
        <i class="material-icons left">vpn_key</i>–°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –∫–ª—é—á
      </button>

      <div id="result" class="card-panel" style="display:none; margin-top:20px;"></div>
      <div id="linkResult" style="display:none; margin-top:20px;"></div>
    </div>
  </div>

  <!-- DECRYPT BLOCK -->
  <div class="card" style="margin-top: 30px; margin-bottom: 70px;">
    <div class="card-content">
      <span class="card-title">–î–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ</span>

      <div class="input-field">
        <textarea id="textDecrypt" class="materialize-textarea"></textarea>
        <label for="textDecrypt">–í—Å—Ç–∞–≤—å—Ç–µ –ø–∞–∫–µ—Ç</label>
      </div>

      <div class="input-field">
        <input id="keyDecrypt" type="text">
        <label for="keyDecrypt">–ö–ª—é—á</label>
      </div>

      <button class="btn orange waves-effect waves-light" id="decryptBtn">
        <i class="material-icons left">lock_open</i>–î–µ—à–∏—Ñ—Ä–æ–≤–∞—Ç—å
      </button>

      <div id="resultDecrypt" class="card-panel" style="display:none; margin-top:20px;"></div>
    </div>
  </div>

  <!-- –ü–æ–¥–∫–ª—é—á–∞–µ–º Materialize JavaScript -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js"></script>

  <script>
    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Materialize –ø–æ—Å–ª–µ –∑–∞–≥—Ä—É–∑–∫–∏ —Å—Ç—Ä–∞–Ω–∏—Ü—ã
    document.addEventListener('DOMContentLoaded', function() {
      // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –≤—Å–µ—Ö –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤ Materialize
      M.AutoInit();

      // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Ç–µ–∫—Å—Ç–æ–≤—ã—Ö –ø–æ–ª–µ–π
      M.updateTextFields();

      // –ü—Ä–∏–≤—è–∑–∫–∞ —Å–æ–±—ã—Ç–∏–π –¥–ª—è –≤—Å–µ—Ö textarea
      const textareas = document.querySelectorAll('textarea');
      textareas.forEach(textarea => {
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∞–≤—Ç–æ—Ä–∞—Å—Ç—è–≥–∏–≤–∞–Ω–∏—è –¥–ª—è textarea
        M.textareaAutoResize(textarea);

        // –î–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è –ø–æ–¥–Ω—è—Ç–∏—è –º–µ—Ç–∫–∏ –ø—Ä–∏ —Ñ–æ–∫—É—Å–µ
        textarea.addEventListener('focus', function() {
          const label = this.nextElementSibling;
          if (label && label.classList.contains('active')) {
            label.classList.add('active');
          }
        });

        // –î–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –∑–Ω–∞—á–µ–Ω–∏—è
        textarea.addEventListener('input', function() {
          const label = this.nextElementSibling;
          if (this.value.trim() !== '') {
            label.classList.add('active');
          } else {
            label.classList.remove('active');
          }
        });

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –º–µ—Ç–∫—É –µ—Å–ª–∏ –µ—Å—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ
        if (textarea.value.trim() !== '') {
          const label = textarea.nextElementSibling;
          label.classList.add('active');
        }
      });

      // –ü—Ä–∏–≤—è–∑–∫–∞ —Å–æ–±—ã—Ç–∏–π –¥–ª—è –≤—Å–µ—Ö input
      const inputs = document.querySelectorAll('input');
      inputs.forEach(input => {
        // –î–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è –ø–æ–¥–Ω—è—Ç–∏—è –º–µ—Ç–∫–∏ –ø—Ä–∏ —Ñ–æ–∫—É—Å–µ
        input.addEventListener('focus', function() {
          const label = this.nextElementSibling;
          if (label && label.classList.contains('active')) {
            label.classList.add('active');
          }
        });

        // –î–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –∑–Ω–∞—á–µ–Ω–∏—è
        input.addEventListener('input', function() {
          const label = this.nextElementSibling;
          if (this.value.trim() !== '') {
            label.classList.add('active');
          } else {
            label.classList.remove('active');
          }
        });

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –º–µ—Ç–∫—É –µ—Å–ª–∏ –µ—Å—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ
        if (input.value.trim() !== '') {
          const label = input.nextElementSibling;
          label.classList.add('active');
        }
      });
    });

    function bytesToBase64Url(bytes) {
      const b64 = btoa(String.fromCharCode(...bytes));
      return b64.replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
    }

    function base64UrlToBytes(b64url) {
      let b64 = b64url.replace(/-/g, "+").replace(/_/g, "/");
      while (b64.length % 4) b64 += "=";
      const bin = atob(b64);
      const arr = new Uint8Array(bin.length);
      for (let i = 0; i < bin.length; i++) arr[i] = bin.charCodeAt(i);
      return arr;
    }

    /* ---------- key generation & import ---------- */
    function generateRawKeyBytes() {
      return crypto.getRandomValues(new Uint8Array(32)); // 256-bit
    }

    function generateKeyString() {
      return bytesToBase64Url(generateRawKeyBytes());
    }

    async function importAesKey(rawBytes) {
      return await crypto.subtle.importKey("raw", rawBytes, { name: "AES-GCM" }, false, ["encrypt", "decrypt"]);
    }

    /* ---------- encrypt/decrypt using raw key bytes ---------- */
    async function encryptWithRawKey(plainText, rawKeyBytes) {
      const key = await importAesKey(rawKeyBytes);
      const iv = crypto.getRandomValues(new Uint8Array(12)); // 12 bytes recommended for GCM
      const enc = new TextEncoder().encode(plainText);
      const ct = await crypto.subtle.encrypt({ name: "AES-GCM", iv }, key, enc);
      return {
        v: 1,
        algo: "AES-GCM",
        iv: bytesToBase64Url(iv),
        cipher: bytesToBase64Url(new Uint8Array(ct))
      };
    }

    async function decryptWithRawKey(blob, rawKeyBytes) {
      const key = await importAesKey(rawKeyBytes);
      const iv = base64UrlToBytes(blob.iv);
      const ct = base64UrlToBytes(blob.cipher);
      const plainBuf = await crypto.subtle.decrypt({ name: "AES-GCM", iv }, key, ct);
      return new TextDecoder().decode(plainBuf);
    }

    /* ---------- pack/unpack JSON -> base64 string for easy copy/paste ---------- */
    function packBlobJSON(blobObj) {
      return btoa(JSON.stringify(blobObj));
    }

    function unpackBlobJSON(packedStr) {
      return JSON.parse(atob(packedStr));
    }

    /* ---------- helpers: clipboard + download + disable UI ---------- */
    async function writeClipboard(text) {
      if (navigator.clipboard && navigator.clipboard.writeText) {
        await navigator.clipboard.writeText(text);
        return true;
      }
      // fallback
      const ta = document.createElement("textarea");
      ta.value = text;
      document.body.appendChild(ta);
      ta.select();
      try { document.execCommand("copy"); } catch (e) { /* ignore */ }
      ta.remove();
      return false;
    }

    function downloadText(filename, text) {
      const blob = new Blob([text], { type: "text/plain" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    function setUIEnabled(enabled) {
      const encBtn = document.getElementById("encryptBtn");
      const decBtn = document.getElementById("decryptBtn");
      const genBtn = document.getElementById("genKeyBtn");

      if (encBtn) encBtn.disabled = !enabled;
      if (decBtn) decBtn.disabled = !enabled;
      if (genBtn) genBtn.disabled = !enabled;
    }

    /* ---------- UI handlers ---------- */
    function showMessage(msg, color = "blue") {
      const el = document.getElementById("result");
      if (!el) return;
      el.style.display = "block";
      el.style.color = color;
      el.textContent = msg;
    }

    async function handleGenerateKey() {
      try {
        const keyStr = generateKeyString();
        const keyInput = document.getElementById("keyEncrypt");
        keyInput.value = keyStr;

        // –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –º–µ—Ç–∫–∏ Materialize
        const label = keyInput.nextElementSibling;
        if (label && label.tagName === 'LABEL') {
          label.classList.add('active');
        }
        M.updateTextFields();

        showMessage("–ö–ª—é—á —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω. –°–∫–æ–ø–∏—Ä—É–π—Ç–µ –∏ –ø–µ—Ä–µ–¥–∞–π—Ç–µ –æ—Ç–¥–µ–ª—å–Ω–æ.", "green");
      } catch (e) {
        console.error("gen key err", e);
        showMessage("–û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∫–ª—é—á–∞", "red");
      }
    }

    async function handleEncryptPack() {
      setUIEnabled(false);
      try {
        const text = document.getElementById("textEncrypt").value;
        if (!text) {
          showMessage("–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –¥–ª—è —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è", "red");
          setUIEnabled(true);
          return;
        }

        let keyStr = document.getElementById("keyEncrypt").value.trim();
        if (!keyStr) {
          // generate and show to user
          keyStr = generateKeyString();
          const keyInput = document.getElementById("keyEncrypt");
          keyInput.value = keyStr;

          // –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –º–µ—Ç–∫–∏ Materialize
          const label = keyInput.nextElementSibling;
          if (label && label.tagName === 'LABEL') {
            label.classList.add('active');
          }
          M.updateTextFields();

          // user must copy key separately
          alert("–°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω –∫–ª—é—á. –°–∫–æ–ø–∏—Ä—É–π—Ç–µ –∏ —Å–æ—Ö—Ä–∞–Ω–∏—Ç–µ –æ—Ç–¥–µ–ª—å–Ω–æ:\n\n" + keyStr);
          showMessage("–ö–ª—é—á —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω. –°–æ—Ö—Ä–∞–Ω–∏—Ç–µ –µ–≥–æ –æ—Ç–¥–µ–ª—å–Ω–æ.", "green");
        }

        // convert key and encrypt
        const raw = base64UrlToBytes(keyStr);
        const blob = await encryptWithRawKey(text, raw);
        const packed = packBlobJSON(blob);

        const out = document.getElementById("linkResult");
        out.style.display = "block";
        // create elements programmatically (avoids quoting issues)
        out.innerHTML = "";
        const label = document.createElement("label");
        label.textContent = "–ü–∞–∫–µ—Ç (—Å–∫–æ–ø–∏—Ä—É–π—Ç–µ –∏ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –∞–¥—Ä–µ—Å–∞—Ç—É):";
        const ta = document.createElement("textarea");
        ta.id = "packedArea";
        ta.rows = 6;
        ta.style.width = "100%";
        ta.value = packed;
        const div = document.createElement("div");
        div.style.marginTop = ".5rem";
        const copyBtn = document.createElement("button");
        copyBtn.textContent = "–°–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å –ø–∞–∫–µ—Ç";
        copyBtn.className = "btn waves-effect waves-light";
        const dlBtn = document.createElement("button");
        dlBtn.textContent = "–°–∫–∞—á–∞—Ç—å –ø–∞–∫–µ—Ç";
        dlBtn.className = "btn waves-effect waves-light";
        div.appendChild(copyBtn);
        div.appendChild(document.createTextNode(" "));
        div.appendChild(dlBtn);
        out.appendChild(label);
        out.appendChild(ta);
        out.appendChild(div);

        copyBtn.addEventListener("click", async () => {
          await writeClipboard(ta.value);
          showMessage("–ü–∞–∫–µ—Ç —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω –≤ –±—É—Ñ–µ—Ä –æ–±–º–µ–Ω–∞", "green");
        });
        dlBtn.addEventListener("click", () => {
          downloadText("secret.pkg", ta.value);
        });

        showMessage("‚úÖ –£–ø–∞–∫–æ–≤–∞–Ω–æ —É—Å–ø–µ—à–Ω–æ", "green");
      } catch (e) {
        console.error("encrypt error", e);
        showMessage("–û—à–∏–±–∫–∞ –ø—Ä–∏ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–∏: " + (e.message || e), "red");
      } finally {
        setUIEnabled(true);
      }
    }

    async function handleDecrypt() {
      setUIEnabled(false);
      try {
        const packed = document.getElementById("textDecrypt").value.trim();
        const keyStr = document.getElementById("keyDecrypt").value.trim();
        if (!packed || !keyStr) {
          showMessage("–í—Å—Ç–∞–≤—å—Ç–µ –ø–∞–∫–µ—Ç –∏ –∫–ª—é—á!", "red");
          setUIEnabled(true);
          return;
        }

        let blob;
        try {
          blob = unpackBlobJSON(packed);
        } catch (err) {
          showMessage("–ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –ø–∞–∫–µ—Ç–∞ (–Ω–µ —Ç–æ—Ç —Ñ–æ—Ä–º–∞—Ç).", "red");
          setUIEnabled(true);
          return;
        }

        const raw = base64UrlToBytes(keyStr);
        try {
          const plain = await decryptWithRawKey(blob, raw);

          // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç –≤ –±–ª–æ–∫–µ –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è
          const resultDecryptEl = document.getElementById("resultDecrypt");
          resultDecryptEl.style.display = "block";
          resultDecryptEl.style.color = "green";
          resultDecryptEl.textContent = "üîì –†–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω–æ: " + plain;
        } catch (err) {
          const resultDecryptEl = document.getElementById("resultDecrypt");
          resultDecryptEl.style.display = "block";
          resultDecryptEl.style.color = "red";
          resultDecryptEl.textContent = "–û—à–∏–±–∫–∞ –¥–µ—à–∏—Ñ—Ä–æ–≤–∫–∏ (–Ω–µ–≤–µ—Ä–Ω—ã–π –∫–ª—é—á –∏–ª–∏ –ø–æ–≤—Ä–µ–∂–¥—ë–Ω–Ω—ã–π –ø–∞–∫–µ—Ç).";
          console.error("decrypt error", err);
        }

      } finally {
        setUIEnabled(true);
      }
    }

    // –ü—Ä–∏–≤—è–∑–∫–∞ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤ —Å–æ–±—ã—Ç–∏–π –ø–æ—Å–ª–µ –∑–∞–≥—Ä—É–∑–∫–∏ DOM
    document.addEventListener("DOMContentLoaded", function() {
      document.getElementById("genKeyBtn").addEventListener("click", handleGenerateKey);
      document.getElementById("encryptBtn").addEventListener("click", handleEncryptPack);
      document.getElementById("decryptBtn").addEventListener("click", handleDecrypt);

      // –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≤—Å–µ—Ö –ø–æ–ª–µ–π
      M.updateTextFields();
    });

    // quick sanity check in console
    console.info("Client-only crypto script attached. Functions:", {
      generateKeyString: typeof generateKeyString,
      encryptWithRawKey: typeof encryptWithRawKey,
      decryptWithRawKey: typeof decryptWithRawKey
    });
  </script>
</body>
</html>