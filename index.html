<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>üîí Client-only Cryptor</title>
</head>
<body>
  <h2>Client-only Cryptor</h2>

  <textarea id="text" rows="6" placeholder="–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç..."></textarea>
  <input id="key" type="password" placeholder="–ü–∞—Ä–æ–ª—å (–∏–ª–∏ –æ—Å—Ç–∞–≤—å—Ç–µ –ø—É—Å—Ç—ã–º –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏)"/>
  <div>
    <button id="encryptBtn">–®–∏—Ñ—Ä–æ–≤–∞—Ç—å –∏ —É–ø–∞–∫–æ–≤–∞—Ç—å</button>
    <button id="decryptBtn">–î–µ—à–∏—Ñ—Ä–æ–≤–∞—Ç—å –ø–∞–∫–µ—Ç</button>
  </div>

  <div id="result" style="margin-top:1rem;color:blue;"></div>
  <div id="linkResult" style="margin-top:1rem;display:none;"></div>

  <script type="module">
function bytesToBase64Url(bytes) {
  const b64 = btoa(String.fromCharCode(...bytes));
  return b64.replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
}
function base64UrlToBytes(b64url) {
  let b64 = b64url.replace(/-/g, "+").replace(/_/g, "/");
  while (b64.length % 4) b64 += "=";
  const bin = atob(b64);
  const arr = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; i++) arr[i] = bin.charCodeAt(i);
  return arr;
}

/* ---------- key generation & import ---------- */
function generateRawKeyBytes() {
  return crypto.getRandomValues(new Uint8Array(32)); // 256-bit
}
function generateKeyString() {
  return bytesToBase64Url(generateRawKeyBytes());
}
async function importAesKey(rawBytes) {
  return await crypto.subtle.importKey("raw", rawBytes, { name: "AES-GCM" }, false, ["encrypt", "decrypt"]);
}

/* ---------- encrypt/decrypt using raw key bytes ---------- */
async function encryptWithRawKey(plainText, rawKeyBytes) {
  const key = await importAesKey(rawKeyBytes);
  const iv = crypto.getRandomValues(new Uint8Array(12)); // 12 bytes recommended for GCM
  const enc = new TextEncoder().encode(plainText);
  const ct = await crypto.subtle.encrypt({ name: "AES-GCM", iv }, key, enc);
  return {
    v: 1,
    algo: "AES-GCM",
    iv: bytesToBase64Url(iv),
    cipher: bytesToBase64Url(new Uint8Array(ct))
  };
}
async function decryptWithRawKey(blob, rawKeyBytes) {
  const key = await importAesKey(rawKeyBytes);
  const iv = base64UrlToBytes(blob.iv);
  const ct = base64UrlToBytes(blob.cipher);
  const plainBuf = await crypto.subtle.decrypt({ name: "AES-GCM", iv }, key, ct);
  return new TextDecoder().decode(plainBuf);
}

/* ---------- pack/unpack JSON -> base64 string for easy copy/paste ---------- */
function packBlobJSON(blobObj) {
  return btoa(JSON.stringify(blobObj));
}
function unpackBlobJSON(packedStr) {
  return JSON.parse(atob(packedStr));
}

/* ---------- helpers: clipboard + download + disable UI ---------- */
async function writeClipboard(text) {
  if (navigator.clipboard && navigator.clipboard.writeText) {
    await navigator.clipboard.writeText(text);
    return true;
  }
  // fallback
  const ta = document.createElement("textarea");
  ta.value = text;
  document.body.appendChild(ta);
  ta.select();
  try { document.execCommand("copy"); } catch (e) { /* ignore */ }
  ta.remove();
  return false;
}
function downloadText(filename, text) {
  const blob = new Blob([text], { type: "text/plain" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}
function setUIEnabled(enabled) {
  document.getElementById("encryptBtn").disabled = !enabled;
  document.getElementById("decryptBtn").disabled = !enabled;
  document.getElementById("genKeyBtn")?.disabled = !enabled;
}

/* ---------- UI handlers ---------- */
function showMessage(msg, color = "blue") {
  const el = document.getElementById("result");
  if (!el) return;
  el.style.display = "block";
  el.style.color = color;
  el.textContent = msg;
}

async function handleGenerateKey() {
  try {
    const keyStr = generateKeyString();
    const keyInput = document.getElementById("key");
    keyInput.value = keyStr;
    showMessage("–ö–ª—é—á —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω. –°–∫–æ–ø–∏—Ä—É–π—Ç–µ –∏ –ø–µ—Ä–µ–¥–∞–π—Ç–µ –æ—Ç–¥–µ–ª—å–Ω–æ.", "green");
  } catch (e) {
    console.error("gen key err", e);
    showMessage("–û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∫–ª—é—á–∞", "red");
  }
}

async function handleEncryptPack() {
  setUIEnabled(false);
  try {
    const text = document.getElementById("text").value;
    if (!text) { showMessage("–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –¥–ª—è —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è", "red"); setUIEnabled(true); return; }

    let keyStr = document.getElementById("key").value.trim();
    if (!keyStr) {
      // generate and show to user
      keyStr = generateKeyString();
      document.getElementById("key").value = keyStr;
      // user must copy key separately
      alert("–°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω –∫–ª—é—á. –°–∫–æ–ø–∏—Ä—É–π—Ç–µ –∏ —Å–æ—Ö—Ä–∞–Ω–∏—Ç–µ –æ—Ç–¥–µ–ª—å–Ω–æ:\n\n" + keyStr);
      showMessage("–ö–ª—é—á —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω. –°–æ—Ö—Ä–∞–Ω–∏—Ç–µ –µ–≥–æ –æ—Ç–¥–µ–ª—å–Ω–æ.", "green");
    }

    // convert key and encrypt
    const raw = base64UrlToBytes(keyStr);
    const blob = await encryptWithRawKey(text, raw);
    const packed = packBlobJSON(blob);

    const out = document.getElementById("linkResult");
    out.style.display = "block";
    // create elements programmatically (avoids quoting issues)
    out.innerHTML = "";
    const label = document.createElement("label");
    label.textContent = "–ü–∞–∫–µ—Ç (—Å–∫–æ–ø–∏—Ä—É–π—Ç–µ –∏ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –∞–¥—Ä–µ—Å–∞—Ç—É):";
    const ta = document.createElement("textarea");
    ta.id = "packedArea";
    ta.rows = 6;
    ta.style.width = "100%";
    ta.value = packed;
    const div = document.createElement("div");
    div.style.marginTop = ".5rem";
    const copyBtn = document.createElement("button");
    copyBtn.textContent = "–°–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å –ø–∞–∫–µ—Ç";
    const dlBtn = document.createElement("button");
    dlBtn.textContent = "–°–∫–∞—á–∞—Ç—å –ø–∞–∫–µ—Ç";
    div.appendChild(copyBtn);
    div.appendChild(document.createTextNode(" "));
    div.appendChild(dlBtn);
    out.appendChild(label);
    out.appendChild(ta);
    out.appendChild(div);

    copyBtn.addEventListener("click", async () => {
      await writeClipboard(ta.value);
      showMessage("–ü–∞–∫–µ—Ç —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω –≤ –±—É—Ñ–µ—Ä –æ–±–º–µ–Ω–∞", "green");
    });
    dlBtn.addEventListener("click", () => {
      downloadText("secret.pkg", ta.value);
    });

    showMessage("‚úÖ –£–ø–∞–∫–æ–≤–∞–Ω–æ —É—Å–ø–µ—à–Ω–æ", "green");
  } catch (e) {
    console.error("encrypt error", e);
    showMessage("–û—à–∏–±–∫–∞ –ø—Ä–∏ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–∏: " + (e.message || e), "red");
  } finally {
    setUIEnabled(true);
  }
}

async function handleDecrypt() {
  setUIEnabled(false);
  try {
    const packed = document.getElementById("text").value.trim();
    const keyStr = document.getElementById("key").value.trim();
    if (!packed || !keyStr) { showMessage("–í—Å—Ç–∞–≤—å—Ç–µ –ø–∞–∫–µ—Ç –∏ –∫–ª—é—á!", "red"); setUIEnabled(true); return; }

    let blob;
    try {
      blob = unpackBlobJSON(packed);
    } catch (err) {
      showMessage("–ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –ø–∞–∫–µ—Ç–∞ (–Ω–µ —Ç–æ—Ç —Ñ–æ—Ä–º–∞—Ç).", "red");
      setUIEnabled(true);
      return;
    }

    const raw = base64UrlToBytes(keyStr);
    try {
      const plain = await decryptWithRawKey(blob, raw);
      showMessage("üîì –†–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω–æ: " + plain, "green");
      // optionally clear input for burn-after-open UX:
      // document.getElementById("text").value = "";
    } catch (err) {
      showMessage("–û—à–∏–±–∫–∞ –¥–µ—à–∏—Ñ—Ä–æ–≤–∫–∏ (–Ω–µ–≤–µ—Ä–Ω—ã–π –∫–ª—é—á –∏–ª–∏ –ø–æ–≤—Ä–µ–∂–¥—ë–Ω–Ω—ã–π –ø–∞–∫–µ—Ç).", "red");
      console.error("decrypt error", err);
    }

  } finally {
    setUIEnabled(true);
  }
}

/* ---------- attach events after DOM ready ---------- */
(function attach() {
  // add optional generate key button if absent
  if (!document.getElementById("genKeyBtn")) {
    const container = document.createElement("div");
    container.style.marginTop = ".5rem";
    const gen = document.createElement("button");
    gen.id = "genKeyBtn";
    gen.textContent = "–°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –∫–ª—é—á";
    container.appendChild(gen);
    const parent = document.querySelector("div"); // first div container in markup
    if (parent) parent.parentNode.insertBefore(container, parent.nextSibling);
    gen.addEventListener("click", handleGenerateKey);
  } else {
    document.getElementById("genKeyBtn").addEventListener("click", handleGenerateKey);
  }

  const encBtn = document.getElementById("encryptBtn");
  const decBtn = document.getElementById("decryptBtn");
  if (encBtn) encBtn.addEventListener("click", handleEncryptPack);
  if (decBtn) decBtn.addEventListener("click", handleDecrypt);

  // quick sanity check in console
  console.info("Client-only crypto script attached. Functions:", {
    generateKeyString: typeof generateKeyString,
    encryptWithRawKey: typeof encryptWithRawKey,
    decryptWithRawKey: typeof decryptWithRawKey
  });
})();
</script>
</body>
</html>
