<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>üîí Client-only Cryptor</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css">
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <style>
  /* –ü—Ä–æ—Å—Ç–∞—è –∞–Ω–∏–º–∞—Ü–∏—è –¥–ª—è –ø–ª–∞–≤–Ω–æ–≥–æ –ø–æ—è–≤–ª–µ–Ω–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ */
  .result {
    opacity: 0;
    transition: opacity 0.5s ease-in-out;
  }

  .result.show {
    opacity: 1;
  }

  button {
    background-color: #4caf50; /* –ó–µ–ª–µ–Ω—ã–π —Ü–≤–µ—Ç */
    color: white;
    border-radius: 8px;
    padding: 12px 20px;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    transition: background-color 0.3s ease, transform 0.3s ease;
  }

  button:hover {
    background-color: #45a049; /* –¢–µ–º–Ω—ã–π –∑–µ–ª–µ–Ω—ã–π –ø—Ä–∏ –Ω–∞–≤–µ–¥–µ–Ω–∏–∏ */
    transform: scale(1.05);
  }

  textarea, input {
    border-radius: 8px;
    padding: 12px;
    font-size: 1rem;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
  }

  textarea:focus, input:focus {
    outline: none;
    box-shadow: 0 0 10px rgba(66, 133, 244, 0.5);
  }
  </style>
</head>
<body>
  <h2 class="center-align">üîí Client-only Cryptor</h2>

  <div class="input-field">
    <textarea id="text" class="materialize-textarea" placeholder="–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç..."></textarea>
    <label for="text">–¢–µ–∫—Å—Ç –¥–ª—è —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è</label>
  </div>

  <div class="input-field">
    <input id="key" type="text" placeholder="–ü–∞—Ä–æ–ª—å (–∏–ª–∏ –æ—Å—Ç–∞–≤—å—Ç–µ –ø—É—Å—Ç—ã–º –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏)" class="validate">
    <label for="key">–ü–∞—Ä–æ–ª—å</label>
  </div>

  <div class="center-align">
    <button id="encryptBtn" class="btn waves-effect waves-light">
      <i class="material-icons left">lock</i>–®–∏—Ñ—Ä–æ–≤–∞—Ç—å
    </button>
    <button id="decryptBtn" class="btn waves-effect waves-light">
      <i class="material-icons left">lock_open</i>–î–µ—à–∏—Ñ—Ä–æ–≤–∞—Ç—å
    </button>
  </div>

  <div id="result" class="result" style="margin-top:1rem; color: blue;"></div>
  <div id="linkResult" class="result" style="margin-top:1rem; display:none;"></div>

  <script type="module">
function bytesToBase64Url(bytes) {
  const b64 = btoa(String.fromCharCode(...bytes));
  return b64.replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
}
function base64UrlToBytes(b64url) {
  let b64 = b64url.replace(/-/g, "+").replace(/_/g, "/");
  while (b64.length % 4) b64 += "=";
  const bin = atob(b64);
  const arr = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; i++) arr[i] = bin.charCodeAt(i);
  return arr;
}

/* ---------- key generation & import ---------- */
function generateRawKeyBytes() {
  return crypto.getRandomValues(new Uint8Array(32)); // 256-bit
}
function generateKeyString() {
  return bytesToBase64Url(generateRawKeyBytes());
}
async function importAesKey(rawBytes) {
  return await crypto.subtle.importKey("raw", rawBytes, { name: "AES-GCM" }, false, ["encrypt", "decrypt"]);
}

/* ---------- encrypt/decrypt using raw key bytes ---------- */
async function encryptWithRawKey(plainText, rawKeyBytes) {
  const key = await importAesKey(rawKeyBytes);
  const iv = crypto.getRandomValues(new Uint8Array(12)); // 12 bytes recommended for GCM
  const enc = new TextEncoder().encode(plainText);
  const ct = await crypto.subtle.encrypt({ name: "AES-GCM", iv }, key, enc);
  return {
    v: 1,
    algo: "AES-GCM",
    iv: bytesToBase64Url(iv),
    cipher: bytesToBase64Url(new Uint8Array(ct))
  };
}
async function decryptWithRawKey(blob, rawKeyBytes) {
  const key = await importAesKey(rawKeyBytes);
  const iv = base64UrlToBytes(blob.iv);
  const ct = base64UrlToBytes(blob.cipher);
  const plainBuf = await crypto.subtle.decrypt({ name: "AES-GCM", iv }, key, ct);
  return new TextDecoder().decode(plainBuf);
}

/* ---------- pack/unpack JSON -> base64 string for easy copy/paste ---------- */
function packBlobJSON(blobObj) {
  return btoa(JSON.stringify(blobObj));
}
function unpackBlobJSON(packedStr) {
  return JSON.parse(atob(packedStr));
}

/* ---------- helpers: clipboard + download + disable UI ---------- */
async function writeClipboard(text) {
  if (navigator.clipboard && navigator.clipboard.writeText) {
    await navigator.clipboard.writeText(text);
    return true;
  }
  // fallback
  const ta = document.createElement("textarea");
  ta.value = text;
  document.body.appendChild(ta);
  ta.select();
  try { document.execCommand("copy"); } catch (e) { /* ignore */ }
  ta.remove();
  return false;
}
function downloadText(filename, text) {
  const blob = new Blob([text], { type: "text/plain" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}
function setUIEnabled(enabled) {
  const encBtn = document.getElementById("encryptBtn");
  const decBtn = document.getElementById("decryptBtn");
  const genBtn = document.getElementById("genKeyBtn");

  if (encBtn) encBtn.disabled = !enabled;
  if (decBtn) decBtn.disabled = !enabled;
  if (genBtn) genBtn.disabled = !enabled;
}

/* ---------- UI handlers ---------- */
function showMessage(msg, color = "blue") {
  const el = document.getElementById("result");
  if (!el) return;
  el.style.display = "block";
  el.style.color = color;
  el.textContent = msg;
}

async function handleGenerateKey() {
  try {
    const keyStr = generateKeyString();
    const keyInput = document.getElementById("key");
    keyInput.value = keyStr;
    showMessage("–ö–ª—é—á —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω. –°–∫–æ–ø–∏—Ä—É–π—Ç–µ –∏ –ø–µ—Ä–µ–¥–∞–π—Ç–µ –æ—Ç–¥–µ–ª—å–Ω–æ.", "green");
  } catch (e) {
    console.error("gen key err", e);
    showMessage("–û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∫–ª—é—á–∞", "red");
  }
}

async function handleEncryptPack() {
  setUIEnabled(false);
  try {
    const text = document.getElementById("text").value;
    if (!text) { showMessage("–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –¥–ª—è —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è", "red"); setUIEnabled(true); return; }

    let keyStr = document.getElementById("key").value.trim();
    if (!keyStr) {
      // generate and show to user
      keyStr = generateKeyString();
      document.getElementById("key").value = keyStr;
      // user must copy key separately
      alert("–°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω –∫–ª—é—á. –°–∫–æ–ø–∏—Ä—É–π—Ç–µ –∏ —Å–æ—Ö—Ä–∞–Ω–∏—Ç–µ –æ—Ç–¥–µ–ª—å–Ω–æ:\n\n" + keyStr);
      showMessage("–ö–ª—é—á —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω. –°–æ—Ö—Ä–∞–Ω–∏—Ç–µ –µ–≥–æ –æ—Ç–¥–µ–ª—å–Ω–æ.", "green");
    }

    // convert key and encrypt
    const raw = base64UrlToBytes(keyStr);
    const blob = await encryptWithRawKey(text, raw);
    const packed = packBlobJSON(blob);

    const out = document.getElementById("linkResult");
    out.style.display = "block";
    // create elements programmatically (avoids quoting issues)
    out.innerHTML = "";
    const label = document.createElement("label");
    label.textContent = "–ü–∞–∫–µ—Ç (—Å–∫–æ–ø–∏—Ä—É–π—Ç–µ –∏ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –∞–¥—Ä–µ—Å–∞—Ç—É):";
    const ta = document.createElement("textarea");
    ta.id = "packedArea";
    ta.rows = 6;
    ta.style.width = "100%";
    ta.value = packed;
    const div = document.createElement("div");
    div.style.marginTop = ".5rem";
    const copyBtn = document.createElement("button");
    copyBtn.textContent = "–°–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å –ø–∞–∫–µ—Ç";
    const dlBtn = document.createElement("button");
    dlBtn.textContent = "–°–∫–∞—á–∞—Ç—å –ø–∞–∫–µ—Ç";
    div.appendChild(copyBtn);
    div.appendChild(document.createTextNode(" "));
    div.appendChild(dlBtn);
    out.appendChild(label);
    out.appendChild(ta);
    out.appendChild(div);

    copyBtn.addEventListener("click", async () => {
      await writeClipboard(ta.value);
      showMessage("–ü–∞–∫–µ—Ç —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω –≤ –±—É—Ñ–µ—Ä –æ–±–º–µ–Ω–∞", "green");
    });
    dlBtn.addEventListener("click", () => {
      downloadText("secret.pkg", ta.value);
    });

    showMessage("‚úÖ –£–ø–∞–∫–æ–≤–∞–Ω–æ —É—Å–ø–µ—à–Ω–æ", "green");
  } catch (e) {
    console.error("encrypt error", e);
    showMessage("–û—à–∏–±–∫–∞ –ø—Ä–∏ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–∏: " + (e.message || e), "red");
  } finally {
    setUIEnabled(true);
  }
}

async function handleDecrypt() {
  setUIEnabled(false);
  try {
    const packed = document.getElementById("text").value.trim();
    const keyStr = document.getElementById("key").value.trim();
    if (!packed || !keyStr) { showMessage("–í—Å—Ç–∞–≤—å—Ç–µ –ø–∞–∫–µ—Ç –∏ –∫–ª—é—á!", "red"); setUIEnabled(true); return; }

    let blob;
    try {
      blob = unpackBlobJSON(packed);
    } catch (err) {
      showMessage("–ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –ø–∞–∫–µ—Ç–∞ (–Ω–µ —Ç–æ—Ç —Ñ–æ—Ä–º–∞—Ç).", "red");
      setUIEnabled(true);
      return;
    }

    const raw = base64UrlToBytes(keyStr);
    try {
      const plain = await decryptWithRawKey(blob, raw);
      showMessage("üîì –†–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω–æ: " + plain, "green");
      // optionally clear input for burn-after-open UX:
      // document.getElementById("text").value = "";
    } catch (err) {
      showMessage("–û—à–∏–±–∫–∞ –¥–µ—à–∏—Ñ—Ä–æ–≤–∫–∏ (–Ω–µ–≤–µ—Ä–Ω—ã–π –∫–ª—é—á –∏–ª–∏ –ø–æ–≤—Ä–µ–∂–¥—ë–Ω–Ω—ã–π –ø–∞–∫–µ—Ç).", "red");
      console.error("decrypt error", err);
    }

  } finally {
    setUIEnabled(true);
  }
}

/* ---------- attach events after DOM ready ---------- */
(function attach() {
  // add optional generate key button if absent
  if (!document.getElementById("genKeyBtn")) {
    const container = document.createElement("div");
    container.style.marginTop = ".5rem";
    const gen = document.createElement("button");
    gen.id = "genKeyBtn";
    gen.textContent = "–°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –∫–ª—é—á";
    container.appendChild(gen);
    const parent = document.querySelector("div"); // first div container in markup
    if (parent) parent.parentNode.insertBefore(container, parent.nextSibling);
    gen.addEventListener("click", handleGenerateKey);
  } else {
    document.getElementById("genKeyBtn").addEventListener("click", handleGenerateKey);
  }

  const encBtn = document.getElementById("encryptBtn");
  const decBtn = document.getElementById("decryptBtn");
  if (encBtn) encBtn.addEventListener("click", handleEncryptPack);
  if (decBtn) decBtn.addEventListener("click", handleDecrypt);

  // quick sanity check in console
  console.info("Client-only crypto script attached. Functions:", {
    generateKeyString: typeof generateKeyString,
    encryptWithRawKey: typeof encryptWithRawKey,
    decryptWithRawKey: typeof decryptWithRawKey
  });
})();
</script>
</body>
</html>
