<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>Secure Cryptor (minimal)</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
  <style>
    body { font-family: Arial, sans-serif; max-width:800px; margin:2rem auto; }
    textarea,input,select { width:100%; padding:0.7rem; margin-top:0.6rem; border-radius:8px; }
    button { padding:0.8rem 1.2rem; border-radius:8px; cursor:pointer; margin-right:8px; }
    .result { margin-top:1rem; padding:1rem; border-radius:8px; background:#f3f3f3; word-break:break-word; }
  </style>
</head>
<body>
<div>
  <h2>üîí Secure Cryptor (minimal)</h2>

  <div>
    <button onclick="onCreateClicked()" id="actionBtn">–®–∏—Ñ—Ä–æ–≤–∞—Ç—å –∏ —É–ø–∞–∫–æ–≤–∞—Ç—å</button>
    <button onclick="onOpenClicked()">–î–µ—à–∏—Ñ—Ä–æ–≤–∞—Ç—å –ø–∞–∫–µ—Ç</button>
  </div>

  <textarea id="text" rows="6" placeholder="–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç..."></textarea>
  <input id="key" type="password" placeholder="–ö–ª—é—á (–ª—é–±–∞—è –¥–ª–∏–Ω–∞)"/>
  <input id="notifyWebhook" type="url" placeholder="Webhook URL (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)" />

  <div id="lifetimeSection" style="margin-top:0.6rem;">
    <select id="lifetime">
      <option value="hour">1 —á–∞—Å</option>
      <option value="day" selected>1 –¥–µ–Ω—å</option>
      <option value="week">1 –Ω–µ–¥–µ–ª—è</option>
    </select>
  </div>

  <div style="margin-top:0.8rem;">
    <button onclick="process()" id="actionBtn">–®–∏—Ñ—Ä–æ–≤–∞—Ç—å</button>
    <button onclick="createSecretLink()">–°–æ–∑–¥–∞—Ç—å —Å—Å—ã–ª–∫—É</button>
  </div>

  <div id="result" class="result"></div>
  <div id="linkResult" class="result" style="display:none;"></div>
</div>

<script>
// ---------- –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ ----------
function bufToBase64(buf) {
  return btoa(String.fromCharCode(...new Uint8Array(buf)));
}
function base64ToBuf(b64) {
  const bin = atob(b64);
  const arr = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; i++) arr[i] = bin.charCodeAt(i);
  return arr.buffer;
}
function strToBuf(s) {
  return new TextEncoder().encode(s);
}
function bufToStr(buf) {
  return new TextDecoder().decode(buf);
}

async function deriveKeyPBKDF2(password, saltBuf, iterations = 200000, keyLen = 256) {
  const baseKey = await crypto.subtle.importKey(
    "raw", strToBuf(password), "PBKDF2", false, ["deriveKey"]
  );
  return await crypto.subtle.deriveKey(
    { name: "PBKDF2", salt: saltBuf, iterations, hash: "SHA-256" },
    baseKey,
    { name: "AES-GCM", length: keyLen },
    true,
    ["encrypt", "decrypt"]
  );
}

async function encryptText(plainText, password) {
  const salt = crypto.getRandomValues(new Uint8Array(16));
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const key = await deriveKeyPBKDF2(password, salt, 200000, 256);
  const cipherBuf = await crypto.subtle.encrypt(
    { name: "AES-GCM", iv },
    key,
    strToBuf(plainText)
  );
  return {
    salt: bufToBase64(salt.buffer),
    iv: bufToBase64(iv.buffer),
    cipher: bufToBase64(cipherBuf),
    iterations: 200000
  };
}

async function decryptBlob(blobObj, password) {
  const saltBuf = base64ToBuf(blobObj.salt);
  const ivBuf = base64ToBuf(blobObj.iv);
  const cipherBuf = base64ToBuf(blobObj.cipher);
  const key = await deriveKeyPBKDF2(password, saltBuf, blobObj.iterations || 200000, 256);
  try {
    const plainBuf = await crypto.subtle.decrypt(
      { name: "AES-GCM", iv: new Uint8Array(ivBuf) },
      key,
      cipherBuf
    );
    return bufToStr(plainBuf);
  } catch (e) {
    throw new Error("–û—à–∏–±–∫–∞: –Ω–µ–≤–µ—Ä–Ω—ã–π –ø–∞—Ä–æ–ª—å –∏–ª–∏ –ø–æ–≤—Ä–µ–∂–¥—ë–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ");
  }
}

function packBlob(obj) {
  return btoa(unescape(encodeURIComponent(JSON.stringify(obj))));
}
function unpackBlob(packedStr) {
  return JSON.parse(decodeURIComponent(escape(atob(packedStr))));
}

function downloadFile(filename, content) {
  const blob = new Blob([content], { type: "application/octet-stream" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}
async function copyToClipboard(text) {
  if (navigator.clipboard) {
    await navigator.clipboard.writeText(text);
  }
}

// ---------- –û—Å–Ω–æ–≤–Ω—ã–µ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ ----------
async function onCreateClicked() {
  const text = document.getElementById("text").value;
  let password = document.getElementById("key").value;
  if (!text) {
    document.getElementById("result").style.color = "#c62828";
    document.getElementById("result").textContent = "–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç!";
    return;
  }
  if (!password) {
    // —Å–≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Å–ª—É—á–∞–π–Ω—ã–π –ø–∞—Ä–æ–ª—å
    password = Array.from(crypto.getRandomValues(new Uint8Array(16)))
      .map(b => ("00" + b.toString(16)).slice(-2))
      .join("");
    alert("–°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω –ø–∞—Ä–æ–ª—å (—Å–æ—Ö—Ä–∞–Ω–∏—Ç–µ –æ—Ç–¥–µ–ª—å–Ω–æ): " + password);
  }
  const enc = await encryptText(text, password);
  const packed = packBlob(enc);

  const resEl = document.getElementById("result");
  resEl.style.color = "#2e7d32";
  resEl.textContent = "‚úÖ –£–ø–∞–∫–æ–≤–∞–Ω–æ —É—Å–ø–µ—à–Ω–æ";

  const out = document.getElementById("linkResult");
  out.style.display = "block";
  out.innerHTML = `
    <textarea id="packedArea" rows="6" style="width:100%;">${packed}</textarea>
    <div style="margin-top:.5rem;">
      <button id="copyBtn">–°–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å</button>
      <button id="downloadBtn">–°–∫–∞—á–∞—Ç—å</button>
    </div>
  `;

  document.getElementById("copyBtn").addEventListener("click", () => {
    copyToClipboard(document.getElementById("packedArea").value);
  });
  document.getElementById("downloadBtn").addEventListener("click", () => {
    downloadFile("secret.pkg", document.getElementById("packedArea").value);
  });
}

async function onOpenClicked() {
  const packed = document.getElementById("text").value.trim();
  const password = document.getElementById("key").value;
  if (!packed || !password) {
    document.getElementById("result").style.color = "#c62828";
    document.getElementById("result").textContent = "–í–≤–µ–¥–∏—Ç–µ –ø–∞–∫–µ—Ç –∏ –ø–∞—Ä–æ–ª—å!";
    return;
  }
  try {
    const blob = unpackBlob(packed);
    const plain = await decryptBlob(blob, password);
    document.getElementById("result").style.color = "#2e7d32";
    document.getElementById("result").textContent = "üîì –†–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω–æ: " + plain;
  } catch (e) {
    document.getElementById("result").style.color = "#c62828";
    document.getElementById("result").textContent = e.message;
  }
}
</script>
</body>
</html>