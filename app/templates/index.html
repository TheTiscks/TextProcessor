<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>Secure Cryptor (minimal)</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
  <style>
    body { font-family: Arial, sans-serif; max-width:800px; margin:2rem auto; }
    textarea,input,select { width:100%; padding:0.7rem; margin-top:0.6rem; border-radius:8px; }
    button { padding:0.8rem 1.2rem; border-radius:8px; cursor:pointer; margin-right:8px; }
    .result { margin-top:1rem; padding:1rem; border-radius:8px; background:#f3f3f3; word-break:break-word; }
  </style>
</head>
<body>
<div>
  <h2>üîí Secure Cryptor (minimal)</h2>

  <div>
    <button onclick="onCreateClicked()" id="actionBtn">–®–∏—Ñ—Ä–æ–≤–∞—Ç—å –∏ —É–ø–∞–∫–æ–≤–∞—Ç—å</button>
    <button onclick="onOpenClicked()">–î–µ—à–∏—Ñ—Ä–æ–≤–∞—Ç—å –ø–∞–∫–µ—Ç</button>
  </div>

  <textarea id="text" rows="6" placeholder="–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç..."></textarea>
  <input id="key" type="password" placeholder="–ö–ª—é—á (–ª—é–±–∞—è –¥–ª–∏–Ω–∞)"/>
  <input id="notifyWebhook" type="url" placeholder="Webhook URL (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)" />

  <div id="lifetimeSection" style="margin-top:0.6rem;">
    <select id="lifetime">
      <option value="hour">1 —á–∞—Å</option>
      <option value="day" selected>1 –¥–µ–Ω—å</option>
      <option value="week">1 –Ω–µ–¥–µ–ª—è</option>
    </select>
  </div>

  <div style="margin-top:0.8rem;">
    <button onclick="process()" id="actionBtn">–®–∏—Ñ—Ä–æ–≤–∞—Ç—å</button>
    <button onclick="createSecretLink()">–°–æ–∑–¥–∞—Ç—å —Å—Å—ã–ª–∫—É</button>
  </div>

  <div id="result" class="result"></div>
  <div id="linkResult" class="result" style="display:none;"></div>
</div>

<script>
// ---------- –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ base64 / UTF-8 ----------
function bufToBase64(buf) {
  return btoa(String.fromCharCode(...new Uint8Array(buf)));
}
function base64ToBuf(b64) {
  const bin = atob(b64);
  const arr = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; i++) arr[i] = bin.charCodeAt(i);
  return arr.buffer;
}
function strToBuf(s) {
  return new TextEncoder().encode(s);
}
function bufToStr(buf) {
  return new TextDecoder().decode(buf);
}

// ---------- KDF: PBKDF2 -> AES-GCM key ----------
async function deriveKeyPBKDF2(password, saltBuf, iterations = 200000, keyLen = 256) {
  const alg = { name: "PBKDF2" };
  const baseKey = await window.crypto.subtle.importKey(
    "raw", strToBuf(password), alg, false, ["deriveKey"]
  );
  const derived = await window.crypto.subtle.deriveKey(
    {
      name: "PBKDF2",
      salt: saltBuf,
      iterations: iterations,
      hash: "SHA-256",
    },
    baseKey,
    { name: "AES-GCM", length: keyLen },
    true,
    ["encrypt", "decrypt"]
  );
  return derived;
}

// ---------- Encrypt text -> returns object with iv + cipher (ArrayBuffer) ----------
async function encryptText(plainText, password) {
  const salt = window.crypto.getRandomValues(new Uint8Array(16));
  const iv = window.crypto.getRandomValues(new Uint8Array(12));
  const key = await deriveKeyPBKDF2(password, salt, 200000, 256);
  const cipherBuf = await window.crypto.subtle.encrypt(
    { name: "AES-GCM", iv: iv },
    key,
    strToBuf(plainText)
  );
  return {
    salt: bufToBase64(salt.buffer),
    iv: bufToBase64(iv.buffer),
    cipher: bufToBase64(cipherBuf)
  };
}

// ---------- Decrypt: takes the fields and password ----------
async function decryptBlob(blobObj, password) {
  const saltBuf = base64ToBuf(blobObj.salt);
  const ivBuf = base64ToBuf(blobObj.iv);
  const cipherBuf = base64ToBuf(blobObj.cipher);
  const key = await deriveKeyPBKDF2(password, saltBuf, blobObj.iterations || 200000, 256);
  try {
    const plainBuf = await window.crypto.subtle.decrypt(
      { name: "AES-GCM", iv: new Uint8Array(ivBuf) },
      key,
      cipherBuf
    );
    return bufToStr(plainBuf);
  } catch (e) {
    // –≤–æ–∑–º–æ–∂–Ω–∞ –æ—à–∏–±–∫–∞ –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏ (–Ω–µ–≤–µ—Ä–Ω—ã–π –∫–ª—é—á / –ø–æ–≤—Ä–µ–∂–¥—ë–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ)
    throw new Error("Decryption failed: bad password or corrupted data");
  }
}

// ---------- Pack/unpack the standard JSON format ----------
function packBlob({ salt, iv, cipher, iterations = 200000 }) {
  const json = {
    v: 1,
    kdf: "PBKDF2",
    hash: "SHA-256",
    iterations: iterations,
    salt: salt,
    algo: "AES-GCM",
    iv: iv,
    cipher: cipher
  };
  // encode whole JSON as base64 for compact single-line string
  const jstr = JSON.stringify(json);
  return btoa(unescape(encodeURIComponent(jstr)));
}
function unpackBlob(packedStr) {
  const jstr = decodeURIComponent(escape(atob(packedStr)));
  return JSON.parse(jstr);
}

// ---------- Helpers: download file & copy to clipboard ----------
function downloadFile(filename, content) {
  const blob = new Blob([content], { type: "application/octet-stream" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}
async function copyToClipboard(text) {
  if (navigator.clipboard) {
    await navigator.clipboard.writeText(text);
  } else {
    // fallback
    const ta = document.createElement("textarea");
    ta.value = text;
    document.body.appendChild(ta);
    ta.select();
    document.execCommand("copy");
    ta.remove();
  }
}

// ---------- Integration examples (use in your UI) ----------
async function createClientOnlyPackage(plainText, password) {
  const enc = await encryptText(plainText, password);
  // pack to compact string
  const packed = packBlob(enc);
  return { packed, key: password }; // key == password (or separate random string)
}

// Parse and decrypt package
async function openClientOnlyPackage(packedStr, password) {
  const blob = unpackBlob(packedStr);
  const plain = await decryptBlob(blob, password);
  return plain;
}

// ---------- Example usage for your UI handlers ----------
async function onCreateClicked() {
  const text = document.getElementById('text').value;
  // either ask user for password or generate random
  let password = document.getElementById('key').value;
  if (!password) {
    // generate a random 32-char key for user to copy
    password = Array.from(crypto.getRandomValues(new Uint8Array(32)))
                    .map(b => ("00" + b.toString(16)).slice(-2)).join("");
    alert("Generated random key ‚Äî copy and save it securely: " + password);
  }
  const { packed } = await createClientOnlyPackage(text, password);
  // show packed string (single-line), allow download and copy
  document.getElementById('result').style.color = "#2e7d32";
  document.getElementById('result').textContent = "Encrypted package (copy+send):";
  const out = document.getElementById('linkResult');
  out.style.display = 'block';
  out.innerHTML = '<textarea rows="6" style="width:100%;">' + packed + '</textarea>'
    + '<div style="margin-top:.5rem;"><button onclick="copyToClipboard(document.querySelector(\\'#linkResult textarea\\').value)">Copy</button>'
    + '<button onclick="downloadFile(\\'secret.pkg\\', document.querySelector(\\'#linkResult textarea\\').value)">Download</button></div>';
}

async function onOpenClicked() {
  const packed = document.getElementById('text').value.trim();
  const password = document.getElementById('key').value;
  try {
    const plain = await openClientOnlyPackage(packed, password);
    document.getElementById('result').style.color = "#2e7d32";
    document.getElementById('result').textContent = "Decrypted: " + plain;
  } catch (e) {
    document.getElementById('result').style.color = "#c62828";
    document.getElementById('result').textContent = e.message;
  }
}
</script>
</body>
</html>